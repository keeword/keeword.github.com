---
layout: post
title: x86 内存管理机制发展
category: 
tags: [x86, memory management]
---

本文主要讲述 x86 体系从 8086 到 80386 的内存管理机制。

内存管理机制主要解决 `内存寻址` 、 `内存保护` 、 `内存缓存` 等问题。

## 直接寻址

在内存抽象模型还未出现的早期，内存地址只有物理地址这一概念，
程序都是直接访问物理地址，可以说根本就没有内存管理机制。
所以计算机每次只能运行一个程序。

## 段寻址（segment）

### 8086

intel 8086 是 16 位的 CPU ，有 16 位的寄存器、 16 位的内部和外部数据总线、 20 位的外部地址总线。
20 位的外部地址总线理论上能寻址 $2^{20} B = 1 M$ 大小的内存，
而用 16 位的寄存器保存内存地址的话，只能寻址 $2^{16} B = 64 K$ 大小的内存，
为了解决这个矛盾， intel 引入了 ‘逻辑地址’ 的概念，采用 ‘段寻址’ 的方式把
‘逻辑地址’ 映射到 ‘物理地址’ 。

为了实现段机制， 8086 里引入了 4 个寄存器：
CS(code segment)、DS(data segment)、SS(stack segment)、ES(extra segment) ，
分别用于保存程序中各段的基址地址。
逻辑地址通常以 `[selector:offset]` 的形式表示，它与物理地址的转换关系如下：
$physicalsadrress = selector * 16 + offset$ 。

在实际程序中，假设 `DS = 0x1000` 、 `SI = 0xFFFF` ，那么 `MOV AL, DS:[DI]`
的功能就是复制内存 $0x1000 * 16 + 0xFFFF = 0x1FFFF$ 处的一个字节复制到 `AL` 中。

理论上，段机制的最大寻址空间为 $0xFFFF * 16 + 0xFFFF = 0x10FFEF = 1M + 64K - 16B$ ，
但由于 20 位的外部总线只能寻址 1M 大小内存，计算超出 1M 大小的地址空间(0x100000 - 0x10FFEF)时，
结果会对 1M 求余，这种技术有时又叫做 `wrap-around` 。

段寻址实际上也存在不少的问题： 
+ 段大小受限：每个段最大为 64K ，如果数据或程序大于这个值就必须分为两部分。 
+ 同一物理地址有多种表达方式：例如 0x01C0:0x0000 和 0x0000:0x1C00 所表示的物理地址都是 0x01C00 。 
+ 没有保护机制：无须任何特权就能够改变段寄存器的值，程序能够随心所欲地访问别的程序的代码和数据。 

### 80286

intel 80286 把 8086 所使用的方法称为实模式(real mode) ，而另外创造了一种新的保护模式(protect mode)。
通常，80286 启动时处于实模式，然后通过指令转移到保护模式。 80286 的实模式是为了向下兼容的一种举措。

80286 把外部地址总线增加到 24 位，所以能够寻址 $2^{24}B = 16M$ 大小的内存，
显然不能再用原来的寻址方式。 80286 把 `selector` 和 `offset` 组合在一起，
形成一个 32 位的虚拟地址指针，同时， `selector` 的格式也与实模式中的不同，
实模式中， `selector` 是物理地址的高位部分，保护模式中的 `selector` 格式如下图所示。

![段选择器格式](/img/format_of_the_segment_selector_component.png)

其中， RPL(request privelege level) 是为了权限管理而设计的标志位，去掉这两位后，
还剩下 30 位，故程序能够访问的最大空间为 $2^{30}B = 1G$ 。


